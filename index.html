<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<title>Snake Game</title>
<style>
  body { display: flex; justify-content: center; align-items: center; height: 100vh; color: #fff; font-family: sans-serif; flex-direction: column; margin:0; background: #222; }
  canvas { background: #000; }
  #score { margin-bottom: 10px; font-size: 20px; }
  #message { margin-top: 10px; font-size: 24px; color: yellow; }
</style>
</head>
<body>
<div id="score">Score: 0 | Level: 1</div>
<canvas id="game" width="600" height="600"></canvas>
<div id="message"></div>

<script>
const canvas = document.getElementById('game');
const ctx = canvas.getContext('2d');
const scoreDisplay = document.getElementById('score');
const messageDisplay = document.getElementById('message');

const grid = 20;
let speed = 6;
let count = 0;
let snake = [{x: 240, y: 240}];
let dx = grid;
let dy = 0;
let food = {x: 0, y: 0};
let score = 0;
let level = 1;
let highScore = 0;
let gameOver = false;

function getRandomFood() {
    let newFood;
    let isOnSnake;

    // Keep generating new positions until we find one not on the snake
    do {
        newFood = {
            x: Math.floor(Math.random() * canvas.width / grid) * grid,
            y: Math.floor(Math.random() * canvas.height / grid) * grid
        };
        isOnSnake = snake.some(seg => seg.x === newFood.x && seg.y === newFood.y);
    } while (isOnSnake);

    food.x = newFood.x;
    food.y = newFood.y;
}
getRandomFood();

function updateBackground() {
    const colors = ['#fff', '#eee', '#ddd', '#ccc', '#bbb', '#aaa', '#999', '#888'];
    const index = Math.min(level-1, colors.length-1);
    canvas.style.background = colors[index];
}

function resetGame() {
    snake = [{x: 240, y: 240}];
    dx = grid; dy = 0;
    score = 0;
    level = 1;
    speed = 6;
    gameOver = false;
    messageDisplay.textContent = '';
    scoreDisplay.textContent = `Score: 0 | Level: 1 | High Score: ${highScore}`;
    updateBackground();
    getRandomFood();
}

function gameLoop() {
    requestAnimationFrame(gameLoop);
    if (gameOver) return;
    if (++count < speed) return;
    count = 0;

    ctx.clearRect(0, 0, canvas.width, canvas.height);

    let head = {x: snake[0].x + dx, y: snake[0].y + dy};
    snake.unshift(head);

    if (head.x === food.x && head.y === food.y) {
        score += 10;
        if (score > highScore) {
        highScore = score;
        localStorage.setItem('highScore', highScore);
        }

        if (score % 50 === 0) {
            level++;
            updateBackground();
            if (speed > 2) speed--;
        }
        scoreDisplay.textContent = `Score: ${score} | Level: ${level} | High Score: ${highScore}`;
        getRandomFood();
    } else {
        snake.pop();
    }
    // Draw apple
    const appleX = food.x + grid/2;
    const appleY = food.y + grid/2;

    // Apple body (red with slight gradient effect using multiple circles)
    ctx.fillStyle = '#cc0000';
    ctx.beginPath();
    ctx.arc(appleX, appleY, grid/2, 0, Math.PI * 2);
    ctx.fill();

    // Highlight to make it look shiny
    ctx.fillStyle = 'rgba(255, 100, 100, 0.6)';
    ctx.beginPath();
    ctx.arc(appleX - grid/6, appleY - grid/6, grid/4, 0, Math.PI * 2);
    ctx.fill();

    // Brown stem
    ctx.fillStyle = '#654321';
    ctx.fillRect(appleX - 1, appleY - grid/2 - 3, 2, 4);

    // Green leaf
    ctx.fillStyle = '#228B22';
    ctx.beginPath();
    ctx.ellipse(appleX + 3, appleY - grid/2 - 2, 3, 2, Math.PI / 4, 0, Math.PI * 2);
    ctx.fill();


    // Draw snake body with rounded, connected segments
    ctx.fillStyle = '#00aa00';
    snake.slice(1).forEach((seg, index) => {
        // Draw main segment with rounded corners
        ctx.fillRect(seg.x + 1, seg.y + 1, grid - 2, grid - 2);

        // Draw connectors to previous segment for smooth connection
        if (index > 0) {
            const prevSeg = snake.slice(1)[index - 1];
            const nextSeg = seg;

            // If segments are horizontal neighbors
            if (Math.abs(prevSeg.x - nextSeg.x) === grid && prevSeg.y === nextSeg.y) {
                const minX = Math.min(prevSeg.x, nextSeg.x);
                ctx.fillRect(minX + grid/2 - 2, seg.y + 1, grid/2 + 4, grid - 2);
            }
            // If segments are vertical neighbors
            else if (Math.abs(prevSeg.y - nextSeg.y) === grid && prevSeg.x === nextSeg.x) {
                const minY = Math.min(prevSeg.y, nextSeg.y);
                ctx.fillRect(seg.x + 1, minY + grid/2 - 2, grid - 2, grid/2 + 4);
            }
        }

        // Also connect to head if this is the first body segment
        if (index === 0) {
            const head = snake[0];
            // If horizontal neighbors
            if (Math.abs(head.x - seg.x) === grid && head.y === seg.y) {
                const minX = Math.min(head.x, seg.x);
                ctx.fillRect(minX + grid/2 - 2, seg.y + 1, grid/2 + 4, grid - 2);
            }
            // If vertical neighbors
            else if (Math.abs(head.y - seg.y) === grid && head.x === seg.x) {
                const minY = Math.min(head.y, seg.y);
                ctx.fillRect(seg.x + 1, minY + grid/2 - 2, grid - 2, grid/2 + 4);
            }
        }
    });

    // Draw interactive snake head
    const headX = snake[0].x;
    const headY = snake[0].y;

    // Head background (darker green)
    ctx.fillStyle = '#00aa00';
    ctx.fillRect(headX, headY, grid-1, grid-1);

    // Determine eye positions based on direction
    let eyeOffsetX1, eyeOffsetX2, eyeOffsetY1, eyeOffsetY2;
    let tongueX, tongueY, tongueWidth, tongueHeight;

    if (dx > 0) { // Moving right
        eyeOffsetX1 = grid * 0.6; eyeOffsetX2 = grid * 0.6;
        eyeOffsetY1 = grid * 0.25; eyeOffsetY2 = grid * 0.65;
        tongueX = headX + grid - 1; tongueY = headY + grid/2 - 2;
        tongueWidth = 6; tongueHeight = 4;
    } else if (dx < 0) { // Moving left
        eyeOffsetX1 = grid * 0.2; eyeOffsetX2 = grid * 0.2;
        eyeOffsetY1 = grid * 0.25; eyeOffsetY2 = grid * 0.65;
        tongueX = headX - 6; tongueY = headY + grid/2 - 2;
        tongueWidth = 6; tongueHeight = 4;
    } else if (dy > 0) { // Moving down
        eyeOffsetX1 = grid * 0.25; eyeOffsetX2 = grid * 0.65;
        eyeOffsetY1 = grid * 0.6; eyeOffsetY2 = grid * 0.6;
        tongueX = headX + grid/2 - 2; tongueY = headY + grid - 1;
        tongueWidth = 4; tongueHeight = 6;
    } else { // Moving up
        eyeOffsetX1 = grid * 0.25; eyeOffsetX2 = grid * 0.65;
        eyeOffsetY1 = grid * 0.2; eyeOffsetY2 = grid * 0.2;
        tongueX = headX + grid/2 - 2; tongueY = headY - 6;
        tongueWidth = 4; tongueHeight = 6;
    }

    // Draw eyes (white with black pupils)
    ctx.fillStyle = 'white';
    ctx.beginPath();
    ctx.arc(headX + eyeOffsetX1, headY + eyeOffsetY1, grid * 0.15, 0, Math.PI * 2);
    ctx.fill();
    ctx.beginPath();
    ctx.arc(headX + eyeOffsetX2, headY + eyeOffsetY2, grid * 0.15, 0, Math.PI * 2);
    ctx.fill();

    // Draw pupils
    ctx.fillStyle = 'black';
    ctx.beginPath();
    ctx.arc(headX + eyeOffsetX1, headY + eyeOffsetY1, grid * 0.08, 0, Math.PI * 2);
    ctx.fill();
    ctx.beginPath();
    ctx.arc(headX + eyeOffsetX2, headY + eyeOffsetY2, grid * 0.08, 0, Math.PI * 2);
    ctx.fill();

    // Draw tongue (flickers)
    if (count % 2 === 0) {
        ctx.fillStyle = '#ff6666';
        ctx.fillRect(tongueX, tongueY, tongueWidth, tongueHeight);
    }

    if (head.x < 0 || head.x >= canvas.width || head.y < 0 || head.y >= canvas.height ||
        snake.slice(1).some(seg => seg.x === head.x && seg.y === head.y)) {
        gameOver = true;
        messageDisplay.textContent = `GAME OVER! Score: ${score}, Level: ${level}. High Score: ${highScore}. Press R to restart.`;
    }
}

document.addEventListener('keydown', e => {
    if (!gameOver) {
        // Get the position where the head would be with the new direction
        let newDx = dx, newDy = dy;
        if (e.key === 'ArrowLeft' && dx === 0) { newDx = -grid; newDy = 0; }
        else if (e.key === 'ArrowUp' && dy === 0) { newDx = 0; newDy = -grid; }
        else if (e.key === 'ArrowRight' && dx === 0) { newDx = grid; newDy = 0; }
        else if (e.key === 'ArrowDown' && dy === 0) { newDx = 0; newDy = grid; }

        // Check if the new direction would cause collision with the segment behind the head
        if (snake.length > 1) {
            const newHeadX = snake[0].x + newDx;
            const newHeadY = snake[0].y + newDy;
            // If the new position matches the first body segment, ignore the input
            if (newHeadX === snake[1].x && newHeadY === snake[1].y) {
                return;
            }
        }

        // Apply the new direction
        dx = newDx;
        dy = newDy;
    }
    if (gameOver && (e.key === 'r' || e.key === 'R')) {
        resetGame();
    }
});

updateBackground();
requestAnimationFrame(gameLoop);
</script>
</body>
</html>
