<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<title>Snake Game</title>
<style>
  body { display: flex; justify-content: center; align-items: center; height: 100vh; color: #fff; font-family: sans-serif; flex-direction: column; margin:0; background: #222; }
  canvas { background: #000; }
  #score { margin-bottom: 10px; font-size: 20px; }
  #message { margin-top: 10px; font-size: 24px; color: yellow; }
</style>
</head>
<body>
<div id="score">Score: 0 | Level: 1</div>
<canvas id="game" width="400" height="400"></canvas>
<div id="message"></div>

<script>
const canvas = document.getElementById('game');
const ctx = canvas.getContext('2d');
const scoreDisplay = document.getElementById('score');
const messageDisplay = document.getElementById('message');

const grid = 20;
let speed = 6;
let count = 0;
let snake = [{x: 160, y: 160}];
let dx = grid;
let dy = 0;
let food = {x: 0, y: 0};
let score = 0;
let level = 1;
let highScore = 0;
let gameOver = false;

function getRandomFood() {
    food.x = Math.floor(Math.random() * canvas.width / grid) * grid;
    food.y = Math.floor(Math.random() * canvas.height / grid) * grid;
}
getRandomFood();

function updateBackground() {
    const colors = ['#fff', '#eee', '#ddd', '#ccc', '#bbb', '#aaa', '#999', '#888'];
    const index = Math.min(level-1, colors.length-1);
    canvas.style.background = colors[index];
}

function resetGame() {
    snake = [{x: 160, y: 160}];
    dx = grid; dy = 0;
    score = 0;
    level = 1;
    speed = 6;
    gameOver = false;
    messageDisplay.textContent = '';
    scoreDisplay.textContent = `Score: 0 | Level: 1 | High Score: ${highScore}`;
    updateBackground();
    getRandomFood();
}

function gameLoop() {
    requestAnimationFrame(gameLoop);
    if (gameOver) return;
    if (++count < speed) return;
    count = 0;

    ctx.clearRect(0, 0, canvas.width, canvas.height);

    let head = {x: snake[0].x + dx, y: snake[0].y + dy};
    snake.unshift(head);

    if (head.x === food.x && head.y === food.y) {
        score += 10;
        if (score > highScore) {
        highScore = score;
        localStorage.setItem('highScore', highScore);
        }

        if (score % 50 === 0) {
            level++;
            updateBackground();
            if (speed > 2) speed--;
        }
        scoreDisplay.textContent = `Score: ${score} | Level: ${level} | High Score: ${highScore}`;
        getRandomFood();
    } else {
        snake.pop();
    }
    // Draw apple
    const appleX = food.x + grid/2;
    const appleY = food.y + grid/2;

    // Apple body (red with slight gradient effect using multiple circles)
    ctx.fillStyle = '#cc0000';
    ctx.beginPath();
    ctx.arc(appleX, appleY, grid/2, 0, Math.PI * 2);
    ctx.fill();

    // Highlight to make it look shiny
    ctx.fillStyle = 'rgba(255, 100, 100, 0.6)';
    ctx.beginPath();
    ctx.arc(appleX - grid/6, appleY - grid/6, grid/4, 0, Math.PI * 2);
    ctx.fill();

    // Brown stem
    ctx.fillStyle = '#654321';
    ctx.fillRect(appleX - 1, appleY - grid/2 - 3, 2, 4);

    // Green leaf
    ctx.fillStyle = '#228B22';
    ctx.beginPath();
    ctx.ellipse(appleX + 3, appleY - grid/2 - 2, 3, 2, Math.PI / 4, 0, Math.PI * 2);
    ctx.fill();


    // Draw snake body
    ctx.fillStyle = '#00aa00';
    snake.slice(1).forEach(seg => ctx.fillRect(seg.x, seg.y, grid-1, grid-1));

    // Draw interactive snake head
    const headX = snake[0].x;
    const headY = snake[0].y;

    // Head background (darker green)
    ctx.fillStyle = '#00aa00';
    ctx.fillRect(headX, headY, grid-1, grid-1);

    // Determine eye positions based on direction
    let eyeOffsetX1, eyeOffsetX2, eyeOffsetY1, eyeOffsetY2;
    let tongueX, tongueY, tongueWidth, tongueHeight;

    if (dx > 0) { // Moving right
        eyeOffsetX1 = grid * 0.6; eyeOffsetX2 = grid * 0.6;
        eyeOffsetY1 = grid * 0.25; eyeOffsetY2 = grid * 0.65;
        tongueX = headX + grid - 1; tongueY = headY + grid/2 - 2;
        tongueWidth = 6; tongueHeight = 4;
    } else if (dx < 0) { // Moving left
        eyeOffsetX1 = grid * 0.2; eyeOffsetX2 = grid * 0.2;
        eyeOffsetY1 = grid * 0.25; eyeOffsetY2 = grid * 0.65;
        tongueX = headX - 6; tongueY = headY + grid/2 - 2;
        tongueWidth = 6; tongueHeight = 4;
    } else if (dy > 0) { // Moving down
        eyeOffsetX1 = grid * 0.25; eyeOffsetX2 = grid * 0.65;
        eyeOffsetY1 = grid * 0.6; eyeOffsetY2 = grid * 0.6;
        tongueX = headX + grid/2 - 2; tongueY = headY + grid - 1;
        tongueWidth = 4; tongueHeight = 6;
    } else { // Moving up
        eyeOffsetX1 = grid * 0.25; eyeOffsetX2 = grid * 0.65;
        eyeOffsetY1 = grid * 0.2; eyeOffsetY2 = grid * 0.2;
        tongueX = headX + grid/2 - 2; tongueY = headY - 6;
        tongueWidth = 4; tongueHeight = 6;
    }

    // Draw eyes (white with black pupils)
    ctx.fillStyle = 'white';
    ctx.beginPath();
    ctx.arc(headX + eyeOffsetX1, headY + eyeOffsetY1, grid * 0.15, 0, Math.PI * 2);
    ctx.fill();
    ctx.beginPath();
    ctx.arc(headX + eyeOffsetX2, headY + eyeOffsetY2, grid * 0.15, 0, Math.PI * 2);
    ctx.fill();

    // Draw pupils
    ctx.fillStyle = 'black';
    ctx.beginPath();
    ctx.arc(headX + eyeOffsetX1, headY + eyeOffsetY1, grid * 0.08, 0, Math.PI * 2);
    ctx.fill();
    ctx.beginPath();
    ctx.arc(headX + eyeOffsetX2, headY + eyeOffsetY2, grid * 0.08, 0, Math.PI * 2);
    ctx.fill();

    // Draw tongue (flickers)
    if (count % 2 === 0) {
        ctx.fillStyle = '#ff6666';
        ctx.fillRect(tongueX, tongueY, tongueWidth, tongueHeight);
    }

    if (head.x < 0 || head.x >= canvas.width || head.y < 0 || head.y >= canvas.height ||
        snake.slice(1).some(seg => seg.x === head.x && seg.y === head.y)) {
        gameOver = true;
        messageDisplay.textContent = `GAME OVER! Score: ${score}, Level: ${level}. High Score: ${highScore}. Press R to restart.`;
    }
}

document.addEventListener('keydown', e => {
    if (!gameOver) {
        if (e.key === 'ArrowLeft' && dx === 0) { dx = -grid; dy = 0; }
        else if (e.key === 'ArrowUp' && dy === 0) { dx = 0; dy = -grid; }
        else if (e.key === 'ArrowRight' && dx === 0) { dx = grid; dy = 0; }
        else if (e.key === 'ArrowDown' && dy === 0) { dx = 0; dy = grid; }
    }
    if (gameOver && (e.key === 'r' || e.key === 'R')) {
        resetGame();
    }
});

updateBackground();
requestAnimationFrame(gameLoop);
</script>
</body>
</html>
